(ns euler-clojure.core
  ;(:use [clojure.contrib.lazy-seqs :only [primes]])
  (:require [clojure.set :as set]
            [clojure.contrib.math :as math])
  (import [java.lang Math]))

(defn multiple-of-any?
  "Determines if the number n is a multiple of any of the
   numbers in the vector ns."
 [n xs]
 (if (some #(= 0 (mod n %)) xs) true false))

;; For problem 1, we want the sum of all the numbers that are
;; multiples of a number in the given vector of real numbers, up
;; to the given limit.
(defn sum-multiples-less-than
 "Sums numbers up the given limit if the number is a multiple of one of the
  numbers in the given vector"
 [xs limit]
 (reduce + (filter #(multiple-of-any? % xs) (range limit))))

(defn fib-seq []
  ((fn rfib [a b]
     (cons a (lazy-seq (rfib b (+ a b)))))
   0 1))

;; another way of doing from a different euler project I had created
;; Infinite Fibonacci lazy sequence
(def fibs
  (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))

(defn sum-even-fibs-less-than
  "Sum of even Fibonacci terms less than n"
  [n]
  (reduce + (take-while #(< % n) (filter even? fibs))))


;; copy of lazy-seqs/prime as I can't find that any more for
;; clojure.contrib 1.3
;; "Lazy seq of primes."
(def primes
  (concat 
   [2 3 5 7]
   (lazy-seq
    (let [primes-from
	  (fn primes-from [n [f & r]]
	    (if (some #(zero? (rem n %))
		      (take-while #(<= (* % %) n) primes))
	      (recur (+ n f) r)
	      (lazy-seq (cons n (primes-from (+ n f) r)))))
	  wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2
			6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6
			2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]
      (primes-from 11 wheel)))))

(defn triangle-numbers
  "Lazy seq of triangle numbers. 
   The sequence of triangle numbers is generated by adding the
   natural numbers. So the 7th triangle number would be
   1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ..."
  []
  (let [tris (fn tris [curr acc]
               (lazy-seq
                (cons acc (tris (inc curr) (+ acc (inc curr))))))]
    (tris 1 1)))

(defn collatz
  "Collatz problem function.
   Returns results if n is odd: 3n + 1.
   If n is even: n / 2"
  [n]
  (let [even-fn (fn [n] (/ n 2))
        odd-fn (fn [n] (inc (* n 3)))]
    (cond
     (= n 1) 1
     (odd? n) (odd-fn n)
     :else (even-fn n))))

(defn factors-loop
  "Looks for each successive prime number as a factor.
   Returns a vector of all prime factors."
  [n]
  (loop [n n factors [] curr-pos 0]
    (let [p (nth primes curr-pos)
          r (rem n p)]
      (cond
       (= n 1) factors
       (= 0 r) (recur (/ n p) (conj factors p) curr-pos)
       (> (* p p) n) (conj factors n)
       :else (recur n factors (inc curr-pos))))))

(defn first-prime-factor [n]
  (first (drop-while #(not= 0 (rem n %)) primes)))

(defn prime-factors [n]
  (loop [n n
         coll []]
    (if (= n 1)
      coll
      (let [factor (first-prime-factor n)]
        (recur (/ n factor) (conj coll factor))))))

(defn square [n] (* n n))

;; copied from clojure-contrib - don't know where to find it for 1.3
(defn abs "(abs n) is the absolute value of n" [n]
  (cond
   (not (number? n)) (throw (IllegalArgumentException.
			     "abs requires a number"))
   (neg? n) (- n)
   :else n))

;; copied from clojure-contrib - don't know where to find it for 1.3
(defn gcd "(gcd a b) returns the greatest common divisor of a and b" [a b]
  (if (or (not (integer? a)) (not (integer? b)))
    (throw (IllegalArgumentException. "gcd requires two integers"))  
    (loop [a (abs a) b (abs b)]
      (if (zero? b) a,
	  (recur b (mod a b))))))


;; copied from clojure-contrib - don't know where to find it for 1.3
(defn lcm
  "(lcm a b) returns the least common multiple of a and b"
  [a b]
  (when (or (not (integer? a)) (not (integer? b)))
    (throw (IllegalArgumentException. "lcm requires two integers")))
  (cond (zero? a) 0
        (zero? b) 0
        :else (abs (* b (quot a (gcd a b))))))

(defn divisors
  "Returns a set of the divisors for n"
  [n]
  (let [candidates (set/select
                    #(zero? (rem n %))
                    (set (range 2 (inc (quot n 2)))))]
    (conj candidates 1 n)))

(defn num-divisors 
  "Number of divisors for a given number

   See http://clojure.roboloco.net/?p=140 and
       http://en.wikipedia.org/wiki/Divisor_function"
  [n]
  (let [freqs (reduce #(assoc %1 %2 (inc (get %1 %2 0)))
                      {} (prime-factors n))]
    (reduce #(* %1 (inc %2)) 1 (vals freqs))))

(defn fact
  "Factorial of a positive number.
   Result is product of all numbers less than or equal to number."
  [num]
  {:pre [(pos? num)]}
  (reduce * (range 2 (inc num))))

(defn num-digits
  "Number of digits in a given number"
  [n]
  ;; add 1 to n. Log10 of 1 is 0, so need to bump it up.
  (if (= n 0)
    1
    (int (Math/ceil (Math/log10 (inc (Math/abs n)))))))

(defn digits
  "Seq of individual digits in a number."
  [n]
  (if (= n 0)
    [0]
    (vec (let [ns (loop [n (math/abs n) ds [] idx 10]
                    (let [r (mod n idx)]
                      (if (= n 0)
                        ds
                        (recur (- n r)
                               (cons (quot r (quot idx 10)) ds)
                               (* 10 idx)))))]
           (if (< n 0)
             (map - ns)
             ns)))))
