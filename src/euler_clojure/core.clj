(ns euler-clojure.core
  ;(:use [clojure.contrib.lazy-seqs :only [primes]])
  (:require [clojure.set :as set]
            [clojure.string :as str]
            [clojure.contrib.math :as math])
  (import [java.lang Math]))

(defn multiple-of-any?
  "Determines if the number n is a multiple of any of the
   numbers in the vector ns."
 [n xs]
 (if (some #(= 0 (mod n %)) xs) true false))

;; For problem 1, we want the sum of all the numbers that are
;; multiples of a number in the given vector of real numbers, up
;; to the given limit.
(defn sum-multiples-less-than
 "Sums numbers up the given limit if the number is a multiple of one of the
  numbers in the given vector"
 [xs limit]
 (reduce + (filter #(multiple-of-any? % xs) (range limit))))

(defn fib-seq []
  ((fn rfib [a b]
     (cons a (lazy-seq (rfib b (+ a b)))))
   0 1))

;; another way of doing from a different euler project I had created
;; Infinite Fibonacci lazy sequence
(def fibs
  (map first (iterate (fn [[a b]] [b (+ a b)]) [0 1])))

(defn sum-even-fibs-less-than
  "Sum of even Fibonacci terms less than n"
  [n]
  (reduce + (take-while #(< % n) (filter even? fibs))))


;; copy of lazy-seqs/prime as I can't find that any more for
;; clojure.contrib 1.3
;; "Lazy seq of primes."
(def primes
  (concat 
   [2 3 5 7]
   (lazy-seq
    (let [primes-from
	  (fn primes-from [n [f & r]]
	    (if (some #(zero? (rem n %))
		      (take-while #(<= (* % %) n) primes))
	      (recur (+ n f) r)
	      (lazy-seq (cons n (primes-from (+ n f) r)))))
	  wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2
			6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6
			2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]
      (primes-from 11 wheel)))))

(defn triangle-numbers
  "Lazy seq of triangle numbers. 
   The sequence of triangle numbers is generated by adding the
   natural numbers. So the 7th triangle number would be
   1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ..."
  []
  (let [tris (fn tris [curr acc]
               (lazy-seq
                (cons acc (tris (inc curr) (+ acc (inc curr))))))]
    (tris 1 1)))

(defn collatz
  "Collatz problem function.
   Returns results if n is odd: 3n + 1.
   If n is even: n / 2"
  [n]
  (let [even-fn (fn [n] (/ n 2))
        odd-fn (fn [n] (inc (* n 3)))]
    (cond
     (= n 1) 1
     (odd? n) (odd-fn n)
     :else (even-fn n))))

(defn factors-loop
  "Looks for each successive prime number as a factor.
   Returns a vector of all prime factors."
  [n]
  (loop [n n factors [] curr-pos 0]
    (let [p (nth primes curr-pos)
          r (rem n p)]
      (cond
       (= n 1) factors
       (= 0 r) (recur (/ n p) (conj factors p) curr-pos)
       (> (* p p) n) (conj factors n)
       :else (recur n factors (inc curr-pos))))))

(defn first-prime-factor [n]
  (first (drop-while #(not= 0 (rem n %)) primes)))

(defn prime-factors [n]
  (loop [n n
         coll []]
    (if (= n 1)
      coll
      (let [factor (first-prime-factor n)]
        (recur (/ n factor) (conj coll factor))))))

(defn square [n] (* n n))

;; copied from clojure-contrib - don't know where to find it for 1.3
(defn abs "(abs n) is the absolute value of n" [n]
  (cond
   (not (number? n)) (throw (IllegalArgumentException.
			     "abs requires a number"))
   (neg? n) (- n)
   :else n))

;; copied from clojure-contrib - don't know where to find it for 1.3
(defn gcd "(gcd a b) returns the greatest common divisor of a and b" [a b]
  (if (or (not (integer? a)) (not (integer? b)))
    (throw (IllegalArgumentException. "gcd requires two integers"))  
    (loop [a (abs a) b (abs b)]
      (if (zero? b) a,
	  (recur b (mod a b))))))


;; copied from clojure-contrib - don't know where to find it for 1.3
(defn lcm
  "(lcm a b) returns the least common multiple of a and b"
  [a b]
  (when (or (not (integer? a)) (not (integer? b)))
    (throw (IllegalArgumentException. "lcm requires two integers")))
  (cond (zero? a) 0
        (zero? b) 0
        :else (abs (* b (quot a (gcd a b))))))

(defn divisors
  "Returns a set of the divisors for n"
  [n]
  (let [candidates (set/select
                    #(zero? (rem n %))
                    (set (range 2 (inc (quot n 2)))))]
    (conj candidates 1 n)))

(defn num-divisors 
  "Number of divisors for a given number

   See http://clojure.roboloco.net/?p=140 and
       http://en.wikipedia.org/wiki/Divisor_function"
  [n]
  (let [freqs (reduce #(assoc %1 %2 (inc (get %1 %2 0)))
                      {} (prime-factors n))]
    (reduce #(* %1 (inc %2)) 1 (vals freqs))))

(defn fact
  "Factorial of a positive number.
   Result is product of all numbers less than or equal to number."
  [num]
  {:pre [(pos? num)]}
  (reduce * (range 2 (inc num))))

(defn num-digits
  "Number of digits in a given number"
  [n]
  ;; add 1 to n. Log10 of 1 is 0, so need to bump it up.
  (if (= n 0)
    1
    (int (Math/ceil (Math/log10 (inc (Math/abs n)))))))

(defn digits
  "Seq of individual digits in a number."
  [n]
  (if (= n 0)
    [0]
    (vec (let [ns (loop [n (math/abs n) ds [] idx 10]
                    (let [r (mod n idx)]
                      (if (= n 0)
                        ds
                        (recur (- n r)
                               (cons (quot r (quot idx 10)) ds)
                               (* 10 idx)))))]
           (if (< n 0)
             (map - ns)
             ns)))))

(defn largest-power-of-ten
  "Gets the largest exponent of 10 that will divide the given number.

   Example: (largest-power-of-10 999) ;returns 2"
  [num]
  ;only handling positive numbers for now
  ;{:pre [(pos? num)]}
  (-> num Math/log10 math/floor int))

(defn number-parts
  "Returns vector of each power of ten part of number.

   Example 789 return [700 80 9]"
  [num]
  (loop [n num parts []]
    (if (= 0 n)
      parts
      (let [e (largest-power-of-ten n)
            div (math/expt 10 e)
            q (quot n div)
            r (rem n div)]
        (if (= e 0)
          (conj parts q)
          (recur r (conj parts (* div q))))))))

(def num-word-map
  (sorted-map 1 "one" 2 "two" 3 "three" 4 "four" 5 "five" 6 "six" 
              7 "seven" 8 "eight" 9 "nine" 10 "ten" 11 "eleven"
              12 "twelve" 13 "thirteen" 14 "fourteen" 15 "fifteen"
              16 "sixteen" 17 "seventeen" 18 "eighteen"
              19 "nineteen" 20 "twenty" 30 "thirty"
              40 "forty" 50 "fifty" 60 "sixty" 70 "seventy"
              80 "eighty" 90 "ninety"
              100 "hundred" 
              1000 "thousand"
              1000000 "million"
              1000000000 "billion"))

(defn thousands-part-to-words [digits thousands-part]
  (letfn [(tens-ones-to-words [digits]  
            (if (= 0 (first digits))
              (if (= 0 (second digits))
                ""
                (num-word-map (* 10 (second digits))))
              (if (or (not (second digits)) (= 0 (second digits)))
                (num-word-map (first digits))
                (if (= 1 (second digits))
                  (num-word-map (+ (first digits) (* 10 (second digits))))
                  (str (num-word-map (* 10  (second digits))) "-" 
                       (num-word-map (first digits)))))))
          (hundreds-to-words [digit]
            (if (or (nil? digit) (zero? digit))
              ""
              (str (num-word-map digit) " hundred")))
          (thousands-part-to-words [t]
            (if (or (= t 0) (every? zero? digits))
              ""
              (num-word-map (math/expt 10 (* 3 t)))))]
    (let [tens-ones (tens-ones-to-words (take 2 digits))
          hundreds (hundreds-to-words (nth digits 2 nil))
          and-word (if (and (> (nth digits 2 0) 0)
                            (some (comp not zero?) (take 2 digits)))
                     "and"
                     "")
          thousands (thousands-part-to-words thousands-part)]
      (str/replace
       (str/trim
        (str/join " "
                  [hundreds
                   and-word
                   tens-ones
                   thousands])) #"\s{2,}" " "))))

(defn number-to-words
  "Convert a number to words.

   Examples: 1001 ;one thousand and one
             721  ;seven hundred and twenty-one"
  [num]
  (let [num-parts
        (->> num digits reverse (partition-all 3))
        thousands-parts-words
        (map-indexed (fn [idx itm] (thousands-part-to-words itm idx)) num-parts)
        non-empty-parts (filter (comp not empty?) thousands-parts-words)]
    ; not sure about putting "and" in between. Doesn't seem right.
    (str/replace (str/trim (str/join " and  " (reverse non-empty-parts)))
                 #"\s{2,}" " ")))
